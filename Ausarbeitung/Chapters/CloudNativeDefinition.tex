%=========================================
% 	   Cloud Native     		 =
%=========================================
\chapter{Cloud Native}

In diesem Kapitel gehen wir auf die Definition von Cloud-Native Architekturen ein, grenzen sie von anderen Absätzen ab und betrachten wichtige Eigenschaften. Abschließend beschäftigen wir uns mit den Vor-und Nachteilen und den typischen Einsatzgebieten.

\section{Cloud Computing}
Bevor wir uns mit Cloud-Native auseinandersetzten können, müssen wir uns zuerst mit dem Cloud Computing beschäftigen, da es nämlich die Basis für diese Architekturen bildet und sie maßgeblich beeinflusst. Die NIST Definition von Cloud Computing enthält die wichtigsten Merkmalen.

Cloud computing is a model for enabling ubiquitous, convenient, on-demand network access to a shared pool of configurable computing resources (e.g., networks, servers, storage, applications, and services) that can be rapidly provisioned and released with minimal management effort or service provider interaction. This cloud model is composed of five essential characteristics, three service models, and four deployment models. TODO

Entscheidend für Cloud-Native ist nun die schnelle Bereitstellung von Resourcen, denn dies eröffnet neue Möglichkeiten hinsichitlich der Skalierbarkeit und hat dadurch einen starken Einfluss auf die Architekturen.

\section{Definition Cloud Native}
Was genau Cloud-Native ist und wie man es definieren kann ist schwierig, da der Begriff noch relativ neu ist. Eine erste Version einer Definition kommt von der Cloud Native Computing Foundation, einer Organisation, die als Vorreiter in Sachen Cloud-Native gilt.

CNCF Cloud Native Definition v1.0

Cloud native Technologien ermöglichen es Unternehmen, skalierbare Anwendungen in modernen, dynamischen Umgebungen zu implementieren und zu betreiben. Dies können öffentliche, private und Hybrid-Clouds sein. Best Practices, wie Container, Service-Meshs, Microservices, immutable Infrastruktur und deklarative APIs, unterstützen diesen Ansatz.

Die zugrundeliegenden Techniken ermöglichen die Umsetzung von entkoppelten Systemen, die belastbar, handhabbar und beobachtbar sind. Kombiniert mit einer robusten Automatisierung können Softwareentwickler mit geringem Aufwand flexibel und schnell auf Änderungen reagieren.

Die Cloud Native Computing Foundation fördert die Akzeptanz dieser Paradigmen durch die Ausgestaltung eines Open Source Ökosystems aus herstellerneutralen Projekten. Wir demokratisieren modernste und innovative Softwareentwicklungs-Patterns, um diese Innovationen für alle zugänglich zu machen.

TODO wichtigsten punkte nennen


\section{Microservices}
TODO definition
warum braucht man das im cloud native bereich
Eigenschaften, Vorteile
- um diese microservices zu verwalten werden ... TODO\\
Microservices sind in Cloud Native Systemen zum Erstellen von Anwendungen ein beliebter Architekturstil. Bei dieser Architektur besteht die Software aus kleinen, unabhängigen Services bzw. Modulen, die über definierte APIs (application programming interface) kommunizieren. Jeder Service kann unabhängig von anderen Services entwickelt und bereitgestellt werden, ohne die Funktionalität anderer Services zu beeinträchtigen. Den Aufbau der Microservice-Architektur sowie die Darstellung der einzelnen unabhängigen Services sind in Abbildung \ref{micro} zu sehen.\\
\begin{figure}[bth] 
	\centering
	\includegraphics[width=0.6\textwidth]{Graphics/Microservice.png}
	\caption{Aufbau einer Microservice-Architektur}
	\label{micro}
\end{figure}\\
Durch die Eigenständigkeit besitzt jeder Komponentenservice seinen eigenen Code sowie seine eigene Implementierung. Jede einzelne Komponente ist auf eine Reihe von Funktionen spezialisiert, sodass sie sich auf die Lösung eines bestimmten Problems fokussiert. Wenn ein einzelner Service (z.B. hinsichtlich des Codes) zu komplex wird, kann er in kleinere Services unterteilt werden.\\
In Cloud Native Systemen sowie in der Microservice-Architektur ist die Skalierung ein wichtiger Bestandteil. Durch die Existenz der einzelnen Services können diese je nach Nachfrage unabhängig voneinander skaliert werden. Dadurch können Subsysteme, die mehr Ressourcen benötigen aufskaliert werden, ohne die gesamte Anwendung aufzuskalieren.\\
Eine weitere Eigenschaft ist die Flexibilität. Durch die Unabhängigkeit der einzelnen Services wird auch deren Verwaltung vereinfacht. Bei einer Erweiterung sowie Fehlerbehebung der Anwendung muss nur der entsprechende Service verändert werden. Dies führt dazu, dass nicht die gesamte Anwendung erneut bereitgestellt werden muss.\\
Durch die einfache Bereitstellung können z.B. neue Konzepte ausprobiert und auch schnell wieder rückgängig gemacht werden. Auf Grund der möglichen Experimente entstehen niedrige Ausfallkosten, die Aktualisierung des Codes wird erleichtert und vereinfacht das Hinzufügen neuer Funktionen.
\\

\section{Container}
definition
warum braucht man das im cloud native bereich
Eigenschaften, Vorteile
Docker, Kubernetes\\

- Standard-Software-Einheit, die den Code und seine Abhängigkeiten verpackt
 -> Anwendung schnell und zuverlässig von einer Umgebung zur anderen ausgeführt werden kann \\
- Bieten schlanke und unveränderliche Infrastruktur für die Paketierung und Bereitstellung von Anwendungen\\
- Cloud native Anwendungen nutzen Container für ein einheitliches Betriebssystem, denn durch den geringen Verwaltungsaufwand und die hohe Dichte können viele Container auf demselben virtuellen Computer gehostet werden\\

Vorteile: \\
- Weniger Speicherplatz: Virtualisierung auf Betriebssystemebene, mehrere Container direkt auf dem Kernel des Betriebssystems ausgeführt werden -> starten schneller\\
- Isolation: laufen von anderen Anwendungen isoliert\\
- Überall ausführbar/Portabilität: da die Softwarepakete alle Elemente enthalten, die zur Ausführung in beliebten Umgebungen erforderlich sind\\
- Schnelle Skalierbarkeit: können schnell gestartet und angehalten werden -> Ressourcen hoch- und herunterskaliert werden können\\

Docker: Beliebtes Open-Source-Containerformat zur Automatisierung der Bereitstellung von Anwendungen die z.B. in der Cloud ausgeführt werden können\\

Kubernetes: Open-Source-Orchestrierungssystem zur Automatisierung der Verwaltung, Platzierung, Skalierung und des Routings von Containern\\

\section{Abgrenzungen}
gegenüber monolith
Definition, kurz: Eigenschaften anhand von Bild\\

- gesamte Architektur muss skaliert werden, wenn in einem Prozess ein Fehler auftritt\\
- Hinzufügen und Verbessern von Funktionen mit zunehmender Codebasis komplexer
 -> erschwert Umsetzung neuer Konzepte\\
- Erhöhtes Risiko der Anwendungsverfügbarkeit -> viele Abhängige und eng miteinander verbundene Prozesse -> einzelner Prozessausfall erhöht\\

gegenüber virtualisierung\\
kurz: Definition, Vergleich/Abgrenzung anhand von Bild\\

Virtualisierung der gesamten Hardware bzw. Abstraktion der physischen Hardware, die einen Server in viele Server wandelt\\

\section{Eigenschaften}
Als nächstes betrachten wir einige typischen Eigenschaften von Cloud-Native Architekturen. Im nächsten Abschnitt gehen wir dann darauf ein aus welchen Design Prinzipien hervorgehen.

1.) Globale Ebene
Cloud-Native Architekturen sind oft für eine globale Ebene ausgelegt. Das impliziert z.B. das Daten und Dienste mehrfach deployed und Daten von verschiedenen Quellen synchronisiert werden müssen.

2.) Skalierbarkeit
Die entstehenden Architekturen sind skalierbar und können eine sehr große Menge von Benutzern unterstützen. Dies ist besonders in Kombination mit der globalen Ebene, wenn man Sychronisation und Konsistenz betrachtet, eine große Herausforderung.

3.) "Built on the assumption that infrastructure is fluid and failure is constant"
Die Annahme "infrastructure is fluid" bedeutet, dass die unterliegenden Strukturen (Hardware) der nicht konstant sind. So können z.B. Recheneinheiten (CPUs) hinzukommen oder wegfallen. Diese Annahme resultiert aus der Verwendung von Cloud Technologien und bildet die Basis für das Entwerfen von skalierbaren Architekturen.
Die zweite Annahme, dass Fehler konstant auftreten, ergibt sich ebenfalls aus der Verwendung von Cloud Technologien, denn wenn eine große Anzahl von Hardwarekomponenten verwendet wird steigt die Wahrscheinlichkeit von einem Ausfall. Die Architektur muss also die Möglichkeit von Hardwarefehlern miteinbeziehen. Anders kann man dies auch Wiederstandsfähigkeit bezeichnen.

4.) Updates und Tests verlaufen unscheinbar
Die Architekturen sind so entworfen, dass Systeme, ohne Verlust von Verfügbarkeit, geupdatet und getestet werden können.

5.) Sicherheit
Sicherheit spielt eine wichtige Rolle in Cloud-Native Architekturen. Die meisten Systeme bestehen  aus vielen kleinen Teilen, für welche Zugriff auf andere Teile und Autorisierung/Authentifizierung von Benutzern geregelt werden muss.

\section{Vor- und Nachteile}
In diesem Abschnitt nennen und erklären wir einige Vor- und Nachteile von Cloud-Native Architekturen. Wir beginnen mit den Vorteilen.

1. Skalierbarkeit/Elastizität
Aus der Kombination von lose gekoppelten Komponenten und Cloud-Infrastruktur entstehen effektiv skalierbare Architekturen, denn die Komponenten können individuell hoch und runterskaliert werden. Vorraussetzung ist, dass die einzelnen Komponenten unabhängig voneinander und zustandslos sind.

2. Zuverlässigkeit/Wiederstandsfähigkeit
Cloud-Native Architekturen sind robust gegen Ausfälle der unterliegenden Strukturen. Komponenten werden überwacht und bei Bedarf neu gestartet.

3. Änderbarkeit/Wartbarkeit
Da Komponenten weitesgehend voneinander unabhängig sind, können leichter Änderungen gemacht werden, ohne andere Komponenten auch ändern zu müssen.

4. Übertragbarkeit
Durch die Verwendung von Containern und CI/CD Pipelines ist es möglich die Systeme in andere Umgebungen zu installieren. Container ermöglichen dabei eine Uniforme Umgebung für die Komponenten.

5. Cloud-Native Computing Foundation
Die CNCF ist eine Organisation, die die Entwicklung im Cloud-Native Bereich unterstützt. Sie ist ein zentraler Punkt für Informationen zu Best Practices, Standards, Open-Source Projekte und Neuigkeiten im Bereich Cloud Native.

Die Liste der Nachteile ist zwar kurz, jedoch sind sie hoch zu gewichten.

1. Komplexität


2. Neuer Ansatz/Technologie
- wenig fachliteratur
- wenig erfahrene entwickler


\section{Einsatzgebiete}
Cloud-Native Architekturen werden derzeit meistens für Systeme benutzt, die entweder mit vielen Daten und/oder mit einer großen Anzahl von Benutzern umgehen müssen. Also generell Systeme, die ein hohes Maß an Skalierbarkeit fordern. Besonders in den Bereichen Streaming und Big Data werden häufig Cloud-Native Architekturen verwendet. 
Beispiele sind der Streaming-Dienst von Netflix sowie die Cloud Platformen von Goolge (Goolge Cloud Platform) und Amazon (AWS). In den Fällen von Google und Amazon werden Platformen angeboten die es wiederum ermöglichen Cloud-Native Applikation zu entwicklen.
Anzumerken ist, dass viele Unternehmen eine Migration ihrer Dienste in die Cloud vorgenommen haben, da die Möglichkeiten für Cloud basierte Systeme erst im letzten Jahrzent wirklich zu einer Option wurde. 